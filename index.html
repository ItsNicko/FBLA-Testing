<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>FBLACER</title>
    <!-- Load a clean, versatile UI font (Inter) from Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="style.css" />
    <!-- Chart.js removed: replaced by aleks-chart.js -->
    <script type="module">
      // Import the functions you need from the SDKs you need
      import { initializeApp } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-app.js";
      import { getAnalytics } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-analytics.js";
      import {
        getAuth,
        signInAnonymously,
        onAuthStateChanged,
        createUserWithEmailAndPassword,
        signInWithEmailAndPassword,
        signOut,
      } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-auth.js";
      import {
        setPersistence,
        browserLocalPersistence,
      } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-auth.js";
      // TODO: Add SDKs for Firebase products that you want to use
      // https://firebase.google.com/docs/web/setup#available-libraries

      // Your web app's Firebase configuration
      // For Firebase JS SDK v7.20.0 and later, measurementId is optional
      const firebaseConfig = {
        apiKey: "AIzaSyCG32qVhboeAYBGYcq9QniwBeiAVMHFvo4",
        authDomain: "fblacer.firebaseapp.com",
        projectId: "fblacer",
        storageBucket: "fblacer.firebasestorage.app",
        messagingSenderId: "410096026599",
        appId: "1:410096026599:web:3d484f1d2d961180e7b342",
        measurementId: "G-C79TMGDW0Q",
      };

      // Initialize Firebase
      const app = initializeApp(firebaseConfig);
      const analytics = getAnalytics(app);
      // Firestore imports and a tiny wrapper API for leaderboard operations
      import {
        getFirestore,
        collection,
        addDoc,
        query,
        orderBy,
        limit,
        getDocs,
        where,
        serverTimestamp,
        doc,
        setDoc,
        getDoc,
        runTransaction,
      } from "https://www.gstatic.com/firebasejs/12.3.0/firebase-firestore.js";

      const db = getFirestore(app);

      // Initialize Auth and sign in anonymously so Firestore rules that require auth pass.
      const auth = getAuth(app);
      // Initialize Auth and prefer persistent login across refreshes.
      try {
        // prefer browser local persistence
        setPersistence(auth, browserLocalPersistence).catch((err) => {
          console.warn("setPersistence failed", err);
        });
      } catch (e) {
        // ignore
      }
      // expose wrappers for the non-module script so it can create/sign-in users and access Firestore
      window.db = db;
      window.auth = auth;
      window.authCreate = (email, password) =>
        createUserWithEmailAndPassword(auth, email, password);
      window.authSignIn = (email, password) =>
        signInWithEmailAndPassword(auth, email, password);
      window.authSignOut = () => signOut(auth);
      window.getDoc = getDoc;
      window.doc = doc;
      window.setDoc = setDoc;
      window.runTransaction = runTransaction;
      window.serverTimestamp = serverTimestamp;
      window.collection = collection;
      window.addDoc = addDoc;
      window.getDocs = getDocs;
      window.query = query;
      window.orderBy = orderBy;
      window.limit = limit;
      window.where = where;

      // 🔧 Dynamic profanity filter loader
      window.bannedWords = [];

      window.loadBannedWords = async () => {
        try {
          const snap = await getDoc(doc(window.db, "config", "bannedWords"));
          window.bannedWords = snap.exists() ? snap.data().words || [] : [];
          console.info("Loaded banned words:", window.bannedWords);
        } catch (err) {
          console.warn("Failed to load banned words:", err);
          window.bannedWords = [];
        }
      };

      // Promise to indicate when auth is ready
      let _authReadyResolve;
      window.leaderboardAuthReady = new Promise((res) => {
        _authReadyResolve = res;
      });

      signInAnonymously(auth)
        .then(() => {
          console.info("Requested anonymous sign-in");
        })
        .catch((err) => {
          console.warn("Anonymous sign-in failed:", err);
          // still resolve so UI doesn't hang; submissions may still fail depending on rules
          if (_authReadyResolve) _authReadyResolve();
        });
      onAuthStateChanged(auth, (user) => {
        if (user) {
          console.info("Signed in uid=", user.uid);
        } else {
          console.info("Not signed in");
          // if nobody is signed in, attempt anonymous sign-in so rules that require auth pass.
          try {
            signInAnonymously(auth)
              .then(() => {
                console.info("Requested anonymous sign-in");
              })
              .catch((err) => {
                console.warn("Anonymous sign-in failed:", err);
              });
          } catch (e) {}
        }
        if (_authReadyResolve) {
          _authReadyResolve();
          _authReadyResolve = null;
        }
      });

      onAuthStateChanged(auth, (user) => {
        if (user) {
          console.info("Signed in (anonymous) uid=", user.uid);
        } else {
          console.info("Not signed in");
        }
        if (_authReadyResolve) {
          _authReadyResolve();
          _authReadyResolve = null;
        }
      });

      // Once auth is ready, attempt to load the dynamic banned-words list from Firestore.
      // We wait for `leaderboardAuthReady` so the anonymous sign-in (if needed) completes first.
      if (window.leaderboardAuthReady) {
        window.leaderboardAuthReady
          .then(() => {
            try {
              if (typeof window.loadBannedWords === "function") {
                window
                  .loadBannedWords()
                  .catch((err) => console.warn("loadBannedWords failed", err));
              }
            } catch (e) {
              console.warn("Error invoking loadBannedWords", e);
            }
          })
          .catch(() => {});
      }

      // leaderboardApi: submitScore(testId, name, points) -> Promise<docRef>
      // fetchTopScores(testId, limitNum, offsetDoc?) -> Promise<array of scores>
      window.leaderboardApi = {
        async submitScore(testId, name, points) {
          if (!testId) throw new Error("missing testId");
          const col = collection(db, "leaderboards", testId, "scores");
          // include the current auth UID when available so clients can link leaderboard
          // entries to public profiles without relying on name->uid lookups.
          const uid =
            auth && auth.currentUser && auth.currentUser.uid
              ? auth.currentUser.uid
              : null;
          const docRef = await addDoc(col, {
            name: name || "Anonymous",
            points: Number(points) || 0,
            uid: uid,
            createdAt: serverTimestamp(),
          });
          return docRef;
        },
        async fetchTopScores(testId, limitNum = 15) {
          if (!testId) throw new Error("missing testId");
          const col = collection(db, "leaderboards", testId, "scores");
          const q = query(col, orderBy("points", "desc"), limit(limitNum));
          const snap = await getDocs(q);
          const out = [];
          snap.forEach((d) => out.push({ id: d.id, ...d.data() }));
          return out;
        },
        // fetch all scores submitted by a given player name for a test
        async fetchScoresByName(testId, name) {
          if (!testId) throw new Error("missing testId");
          if (!name) throw new Error("missing name");
          const col = collection(db, "leaderboards", testId, "scores");
          const q = query(col, where("name", "==", name));
          const snap = await getDocs(q);
          const out = [];
          snap.forEach((d) => out.push({ id: d.id, ...d.data() }));
          return out;
        },
        // set a document with a specific id: useful for the provided compatibility snippet
        async setScoreDoc(testId, docId, data) {
          if (!testId) throw new Error("missing testId");
          if (!docId) throw new Error("missing docId");
          const path = `leaderboards/${testId}/scores/${docId}`;
          // create doc ref and set
          const dref = doc(db, "leaderboards", testId, "scores", docId);
          // Ensure uid is present when possible so downstream clients can resolve profiles.
          const finalData = Object.assign({}, data || {});
          if (!finalData.uid) {
            try {
              const cur =
                auth && auth.currentUser ? auth.currentUser.uid : null;
              if (cur) finalData.uid = cur;
            } catch (e) {
              /* ignore */
            }
          }
          await setDoc(dref, finalData);
          return true;
        },
      };

      // reportApi: sendIssue({ message, email, page }) -> Promise
      window.reportApi = {
        async sendIssue({ message, email, page }) {
          if (!message) throw new Error("missing message");
          // ensure auth ready
          if (window.leaderboardAuthReady) await window.leaderboardAuthReady;
          try {
            const col = collection(db, "reports");
            const docRef = await addDoc(col, {
              message: String(message).slice(0, 2000),
              email: email ? String(email).slice(0, 256) : null,
              page: page || location.pathname || "unknown",
              userAgent: navigator.userAgent || null,
              createdAt: serverTimestamp(),
            });
            return docRef;
          } catch (err) {
            throw err;
          }
        },
      };

      // accounts helper: read/write accounts/{uid}
      window.accounts = {
        async get(uid) {
          if (!uid) throw new Error("missing uid");
          const dref = doc(db, "accounts", uid);
          const snap = await getDoc(dref);
          return snap && snap.exists() ? snap.data() : null;
        },
        async set(uid, data, options = { merge: true }) {
          if (!uid) throw new Error("missing uid");
          const dref = doc(db, "accounts", uid);
          await setDoc(
            dref,
            data,
            options && options.merge ? { merge: true } : undefined
          );
          return true;
        },
      };

      // writeLog wrapper for convenience
      window.writeLog = async function (action, context) {
        if (!action) throw new Error("missing action");
        const id = `${Date.now()}_${Math.random().toString(36).slice(2, 9)}`;
        const dref = doc(db, "logs", id);
        await setDoc(dref, {
          action,
          context: context || {},
          timestamp: serverTimestamp(),
        });
        return true;
      };
    </script>
  </head>
  <body>
    <h1>FBLACER</h1>
    <!-- Settings cog (opens settings modal which contains dark mode toggle + report form) -->
    <button
      id="settingsBtn"
      aria-label="Open settings"
      title="Settings"
      class="settings-btn"
    >
      ⚙️
    </button>

    <!-- Settings modal (hidden by default) -->
    <div
      id="settingsModal"
      class="settings-modal"
      aria-hidden="true"
      style="
        display: none;
        position: fixed;
        inset: 0;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.45);
        z-index: 99998;
      "
    >
      <div
        class="settings-panel"
        style="
          background: var(--surface, #fff);
          color: var(--text-color, #102027);
          padding: 40px;
          border-radius: 12px;
          min-width: 320px;
          max-width: 720px;
          width: 90%;
          box-shadow: 0 12px 40px rgba(0, 0, 0, 0.3);
          position: relative;
        "
      >
        <button
          id="settingsClose"
          class="settings-close"
          aria-label="Close"
          style="
            position: absolute;
            right: 20px;
            top: 12px;
            background: none;
            border: none;
            font-size: 20px;
          "
        >
          ×
        </button>
        <h3 style="margin-top: 0">Settings</h3>
        <div
          class="settings-section"
          style="
            margin-bottom: 14px;
            display: flex;
            align-items: center;
            justify-content: space-between;
          "
        >
          <div style="display: flex; align-items: center; gap: 12px">
            <span id="settingsThemeLabel" style="font-weight: 600"
              >dark/light</span
            >
            <small style="color: var(--muted, #6b7280)">toggle</small>
          </div>
          <label
            class="theme-switch"
            style="display: inline-flex; align-items: center"
          >
            <input
              type="checkbox"
              id="settingsDarkToggle"
              aria-label="Toggle dark mode from settings"
            />
            <span class="slider"></span>
          </label>
        </div>

        <div class="report-section" style="margin-bottom: 6px">
          <h4 style="margin: 6px 0 8px 0">Report an issue</h4>
          <textarea
            id="issueText"
            placeholder="Describe the problem..."
            rows="4"
            class="report-input"
          ></textarea>
          <input
            id="issueEmail"
            placeholder="Email (optional)"
            class="report-input"
          />
          <div class="report-actions">
            <button id="sendIssueBtn">Send report</button>
            <div
              id="reportStatus"
              aria-live="polite"
              class="report-status"
            ></div>
          </div>
        </div>
        <!-- Login / Signup UI -->
        <div
          class="auth-section"
          style="
            margin-top: 12px;
            border-top: 1px dashed rgba(0, 0, 0, 0.06);
            padding-top: 12px;
          "
        >
          <h4 style="margin: 6px 0 8px 0">Login</h4>
          <input
            id="username"
            type="text"
            placeholder="Username"
            class="report-input"
          />
          <input
            id="password"
            type="password"
            placeholder="Password"
            class="report-input"
          />
          <div style="display: flex; gap: 8px; margin-top: 8px">
            <button id="signupBtn">Sign Up</button>
            <button id="loginBtn">Log In</button>
            <button id="logoutBtn" style="display: none">Log Out</button>
          </div>
          <div style="margin-top: 12px">
            <button id="viewProfileBtn">View Public Profile</button>
          </div>
          <div
            id="authStatus"
            style="margin-top: 8px; color: var(--muted, #6b7280)"
          ></div>
        </div>
      </div>
    </div>

    <select id="testSelect"></select>
    <button id="startBtn" onclick="startTest()">Start Test</button>
    <button id="endBtn" style="display: none">End Test Now</button>

    <div id="flashcard-container"></div>
    <div id="chart-container" style="display: none">
      <canvas id="topicChart"></canvas>
      <div id="topicLegend" class="chart-legend" aria-hidden="false"></div>
    </div>

    <!-- Floating indicators -->
    <div id="floating-container" aria-hidden="true"></div>

    <script src="script.js"></script>
  </body>
</html>
