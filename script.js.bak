let tests = [];
let currentTest = null;
let questions = [];
let progress = { done: 0, total: 0 };
let scores = { topics: {} };

let totalPoints = 0;
let streak = 0;
let loseStreak = 0;
let firstAttempt = true;
let topicChart = null;
let _lastChartLabels = null;
let _lastChartData = null;
let testRunning = false;
let _nextFlashcardTimer = null;

const concaveInnerShadowPlugin = {
  id: 'concaveInnerShadow',
  afterDraw(chart, args, options) {
    try {
      if (chart.config.type !== 'doughnut') return;
      const meta = chart.getDatasetMeta(0);
      if (!meta || !meta.data || meta.data.length === 0) return;

      const first = meta.data[0];
      const ctx = chart.ctx;
      const cx = first.x;
      const cy = first.y;
      const innerR = first.innerRadius || first._model && first._model.innerRadius || (chart._metasets && chart._metasets[0] && chart._metasets[0].innerRadius) || 0;
      if (!innerR) return;

      const shadowColor = options && options.shadowColor ? options.shadowColor : 'rgba(0,0,0,0.12)';
      const rimColor = options && options.rimColor ? options.rimColor : 'rgba(255,255,255,0.6)';
      const rimWidth = options && options.rimWidth ? options.rimWidth : Math.max(4, Math.round(innerR * 0.03));

      ctx.save();
      ctx.globalCompositeOperation = 'multiply';
      const g = ctx.createRadialGradient(cx, cy, innerR * 0.25, cx, cy, innerR);
      g.addColorStop(0, 'rgba(0,0,0,0)');
      g.addColorStop(1, shadowColor);
      ctx.beginPath();
      ctx.arc(cx, cy, innerR, 0, Math.PI * 2);
      ctx.fillStyle = g;
      ctx.fill();
      ctx.restore();

      ctx.save();
      ctx.beginPath();
      ctx.arc(cx, cy, innerR - (rimWidth / 2), 0, Math.PI * 2);
      ctx.lineWidth = rimWidth;
      ctx.strokeStyle = rimColor;
      ctx.globalCompositeOperation = 'screen';
      ctx.stroke();
      ctx.restore();
    } catch (e) {
    }
  }
};

if (typeof Chart !== 'undefined' && Chart.register) {
  try { Chart.register(concaveInnerShadowPlugin); } catch (e) { }
}

document.addEventListener('DOMContentLoaded', () => {
  const toggle = document.getElementById('darkModeToggle');
  const root = document.documentElement;
  const saved = localStorage.getItem('fblacer-dark');
  if (saved === '1') {
    root.classList.add('dark');
    if (toggle) toggle.checked = true;
  }
  if (toggle) toggle.addEventListener('change', (e) => {
    if (e.target.checked) { root.classList.add('dark'); localStorage.setItem('fblacer-dark','1'); }
    else { root.classList.remove('dark'); localStorage.setItem('fblacer-dark','0'); }
    if (typeof updateChartTheme === 'function') {
      updateChartTheme();
      try {
        const canvas = document.getElementById('topicChart');
        if (canvas && _lastChartLabels && _lastChartData) {
          createTopicChart(canvas, _lastChartLabels, _lastChartData);
        }
      } catch (e) { }
    }
  });
});

function getSegmentColors() {
  const dark = document.documentElement.classList.contains('dark');
  if (dark) {
    return ['#4cd08a','#3bb0ff','#ffd54f','#ff8a80','#b39ddb'];
  }
  return ['#4CAF50','#2196F3','#FFC107','#E91E63','#9C27B0'];
}

try {
  const root = document.documentElement;
  const classObserver = new MutationObserver((mutations) => {
    for (const m of mutations) {
      if (m.type === 'attributes' && m.attributeName === 'class') {
        setTimeout(() => {
          try { if (typeof updateChartTheme === 'function') updateChartTheme(); } catch (e) { }
        }, 0);
        break;
      }
    }
  });
  classObserver.observe(root, { attributes: true, attributeFilter: ['class'] });
} catch (e) { }

function createTopicChart(ctxEl, labels, data) {
  if (topicChart) {
    try { topicChart.destroy(); } catch (e) { }
    topicChart = null;
  }

  const rootStyles = getComputedStyle(document.documentElement);
  const textColor = rootStyles.getPropertyValue('--text-color').trim() || '#102027';
  const surface = rootStyles.getPropertyValue('--surface').trim() || '#e6eef6';

  const isDark = document.documentElement.classList.contains('dark');
  const cssShadow = rootStyles.getPropertyValue('--shadow-dark').trim();
  const cssRim = rootStyles.getPropertyValue('--shadow-light').trim();
  const shadowColor = cssShadow || (isDark ? 'rgba(0,0,0,0.72)' : 'rgba(0,0,0,0.12)');
  const rimColor = cssRim || (isDark ? 'rgba(255,255,255,0.10)' : 'rgba(255,255,255,0.6)');

  try {
    if (typeof Chart !== 'undefined' && Chart.defaults) {
      Chart.defaults.color = textColor;
      if (!Chart.defaults.plugins) Chart.defaults.plugins = {};
      if (!Chart.defaults.plugins.legend) Chart.defaults.plugins.legend = {};
      Chart.defaults.plugins.legend.labels = Chart.defaults.plugins.legend.labels || {};
      Chart.defaults.plugins.legend.labels.color = textColor;
    }
  } catch (e) { }

  topicChart = new Chart(ctxEl, {
    type: 'doughnut',
    data: {
      labels,
      datasets: [{
        data,
        backgroundColor: getSegmentColors(),
        borderColor: surface,
        borderWidth: 6
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      cutout: '62%',
      plugins: {
        legend: { display: false },
        tooltip: {
          backgroundColor: surface,
          titleColor: textColor,
          bodyColor: textColor,
          borderColor: 'rgba(0,0,0,0.06)',
          borderWidth: 1,
          callbacks: {
            label: function(context) {
              const topic = context.label;
              const { firstAttemptCorrect, total } = scores.topics[topic];
              const pct = total > 0 ? Math.round((firstAttemptCorrect / total) * 100) : 0;
              return `${topic}: ${pct}% (${firstAttemptCorrect}/${total})`;
            }
          }
        }
      },
      elements: { arc: { borderRadius: 8 } }
    }
  });

  try {
    if (topicChart && topicChart.options) {
      topicChart.options.plugins = topicChart.options.plugins || {};
      topicChart.options.plugins.concaveInnerShadow = topicChart.options.plugins.concaveInnerShadow || {};
      topicChart.options.plugins.concaveInnerShadow.shadowColor = shadowColor;
      topicChart.options.plugins.concaveInnerShadow.rimColor = rimColor;
      topicChart.options.plugins.concaveInnerShadow.rimWidth = Math.max(4, Math.round((Math.min(ctxEl.width, ctxEl.height) || 200) * 0.02));
      topicChart.update();
    }
  } catch (e) { }

  try {
    _lastChartLabels = labels.slice();
    _lastChartData = data.slice();
  } catch (e) { }

  try {
    const legendEl = document.getElementById('topicLegend');
    if (legendEl) {
      legendEl.innerHTML = '';
      const colors = getSegmentColors();
      labels.forEach((lab, i) => {
        const item = document.createElement('div');
        item.className = 'item';
        const sw = document.createElement('span');
        sw.className = 'swatch';
        sw.style.background = colors[i % colors.length];
        item.appendChild(sw);
        const txt = document.createElement('span');
        txt.textContent = lab;
        item.appendChild(txt);
        legendEl.appendChild(item);
      });
      try {
        const rootStyles = getComputedStyle(document.documentElement);
        const tc = rootStyles.getPropertyValue('--text-color').trim() || '#102027';
        legendEl.style.color = tc;
      } catch (e) { }
    }
  } catch (e) { }
}

function updateChartTheme() {
  try {
    const canvas = document.getElementById('topicChart');
    if (!canvas) return;

    const rootStyles = getComputedStyle(document.documentElement);
    const textColor = rootStyles.getPropertyValue('--text-color').trim() || '#102027';
    const surface = rootStyles.getPropertyValue('--surface').trim() || '#e6eef6';
    const cssShadow2 = rootStyles.getPropertyValue('--shadow-dark').trim();
    const cssRim2 = rootStyles.getPropertyValue('--shadow-light').trim();
    const isDark = document.documentElement.classList.contains('dark');
    const shadowColor = cssShadow2 || (isDark ? 'rgba(0,0,0,0.72)' : 'rgba(0,0,0,0.12)');
    const rimColor = cssRim2 || (isDark ? 'rgba(255,255,255,0.10)' : 'rgba(255,255,255,0.6)');

    try {
      if (typeof Chart !== 'undefined' && Chart.defaults) {
        Chart.defaults.color = textColor;
        if (!Chart.defaults.plugins) Chart.defaults.plugins = {};
        if (!Chart.defaults.plugins.legend) Chart.defaults.plugins.legend = {};
        Chart.defaults.plugins.legend.labels = Chart.defaults.plugins.legend.labels || {};
        Chart.defaults.plugins.legend.labels.color = textColor;
      }
    } catch (e) { }

    try { if (topicChart) { topicChart.destroy(); topicChart = null; } } catch (e) { }

    if (_lastChartLabels && _lastChartData) {
      createTopicChart(canvas, _lastChartLabels, _lastChartData);
      try {
        const legendEl = document.getElementById('topicLegend');
        if (legendEl) {
          const rootStyles = getComputedStyle(document.documentElement);
          legendEl.style.color = rootStyles.getPropertyValue('--text-color').trim() || '#102027';
        }
      } catch (e) { }
    }
  } catch (e) {
  }
}

fetch('tests.json')
  .then(res => res.json())
  .then(data => {
    tests = data.tests || [];
    populateTestDropdown();
  });

function populateTestDropdown() {
  const dropdown = document.getElementById('testSelect');
  // add a placeholder option at the top so the custom display shows "Select test"
  const placeholder = document.createElement('option');
  placeholder.value = '';
  placeholder.textContent = 'Select test';
  // ensure placeholder is shown initially
  placeholder.selected = true;
  dropdown.appendChild(placeholder);
  tests.forEach((test, idx) => {
    const option = document.createElement('option');
    option.value = idx;
    option.textContent = test.testName;
    dropdown.appendChild(option);
  });
  initCustomSelect();
}

function initCustomSelect(){
  const native = document.getElementById('testSelect');
  if (!native) return;
  const existing = document.getElementById('customSelect');
  if (existing) existing.remove();

  const wrapper = document.createElement('div');
  wrapper.id = 'customSelect';
  wrapper.className = 'custom-select-wrapper center';
  wrapper.style.display = 'inline-block';
  wrapper.style.position = 'relative';

  const display = document.createElement('button');
  display.type = 'button';
  display.className = 'custom-select-display';
  display.textContent = native.options[native.selectedIndex] ? native.options[native.selectedIndex].textContent : 'Select test';
  display.setAttribute('aria-haspopup','listbox');
  display.setAttribute('aria-expanded','false');

  const menu = document.createElement('div');
  menu.className = 'custom-select-menu';
  menu.setAttribute('role','listbox');
  menu.style.position = 'absolute';
  menu.style.top = 'calc(100% + 8px)';
  menu.style.left = '0';
  menu.style.minWidth = '220px';
  menu.style.display = 'none';
  // make menu scrollable and not grow beyond viewport
  menu.style.maxHeight = '320px';
  menu.style.overflowY = 'auto';
  menu.style.boxSizing = 'border-box';

  // add a search input at the top of the menu for filtering options
  const search = document.createElement('input');
  search.type = 'search';
  search.className = 'custom-select-search';
  search.placeholder = 'Search tests...';
  search.setAttribute('aria-label', 'Search tests');
  search.style.boxSizing = 'border-box';
  search.style.width = '100%';
  search.style.padding = '8px 10px';
  search.style.margin = '0 0 6px 0';
  search.style.border = 'none';
  search.style.borderRadius = '8px';
  search.style.fontSize = '14px';
  search.style.background = 'rgba(255,255,255,0.9)';
  search.autocomplete = 'off';
  menu.appendChild(search);

  Array.from(native.options).forEach((opt, i) =>{
    // skip placeholder option (empty value) when building the clickable menu
    if (opt.value === '') return;
    const item = document.createElement('div');
    item.className = 'custom-select-item';
    item.setAttribute('role','option');
    item.textContent = opt.textContent;
    item.dataset.value = opt.value;
    if (native.value === opt.value || native.selectedIndex === i) item.classList.add('selected');
    item.onclick = () => {
      menu.querySelectorAll('.custom-select-item').forEach(it => it.classList.remove('selected'));
      item.classList.add('selected');
      native.value = opt.value;
      native.selectedIndex = i;
      display.textContent = opt.textContent;
      menu.style.display = 'none';
      // menu was closed by selecting an item
      display.setAttribute('aria-expanded', 'false');
      native.dispatchEvent(new Event('change', { bubbles: true }));
    };
    menu.appendChild(item);
  });

  // filter function used by the search box
  function filterMenu(q) {
    const items = menu.querySelectorAll('.custom-select-item');
    const needle = (q || '').trim().toLowerCase();
    items.forEach(it => {
      const txt = it.textContent.trim().toLowerCase();
      if (!needle || txt.indexOf(needle) !== -1) it.style.display = '';
      else it.style.display = 'none';
    });
  }

  // wire up search input
  search.addEventListener('input', (e) => {
    filterMenu(e.target.value);
  });

  display.onclick = () => {
    const open = menu.style.display === 'block';
    menu.style.display = open ? 'none' : 'block';
    display.setAttribute('aria-expanded', String(!open));
  };

  display.addEventListener('keydown', (e)=>{ if (e.key === 'Escape') { menu.style.display='none'; display.setAttribute('aria-expanded','false'); } });

  document.addEventListener('click', (e)=>{
    if (!wrapper.contains(e.target)) { menu.style.display='none'; display.setAttribute('aria-expanded','false'); }
  });

  wrapper.appendChild(display);
  wrapper.appendChild(menu);
  native.parentNode.insertBefore(wrapper, native.nextSibling);

  native.style.display = 'none';
}

function startTest() {
  const dropdown = document.getElementById('testSelect');
  const startBtn = document.getElementById('startBtn');
  const endBtn = document.getElementById('endBtn');
  const selectedIndex = dropdown.value;
  if (selectedIndex === '') return;
  const selected = tests[selectedIndex];
  if (!selected || !selected.path) return;

  fetch(selected.path)
    .then(res => res.json())
    .then(fullTest => {
      currentTest = fullTest.testName ? fullTest : (fullTest.tests && fullTest.tests[0]) || null;
      if (!currentTest) {
        return;
      }

      questions = currentTest.topics.flatMap(t =>
        t.questions.map(q => ({ ...q, topic: t.topic }))
      );
      shuffleArray(questions);

      progress = { done: 0, total: questions.length };
      scores = { topics: {} };
      totalPoints = 0;
      streak = 0;
      loseStreak = 0;
      firstAttempt = true;

      if (document.getElementById('customSelect')) document.getElementById('customSelect').style.display = 'none';
      dropdown.style.display = 'none';
      startBtn.style.display = 'none';
      endBtn.style.display = 'inline-block';

      testRunning = true;
      generateFlashcard();
    })
  .catch(err => {
  });
}

function shuffleArray(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
}

function generateFlashcard() {
  const container = document.getElementById('flashcard-container');
  container.innerHTML = '';

  if (questions.length === 0) {
    endTest();
    return;
  }

  const q = questions.shift();
  // Shuffle options and track new correct answer
  const shuffledOptions = [...q.options];
  shuffleArray(shuffledOptions);

  const correctAnswer = q.correctAnswer;
  const newCorrectAnswer = shuffledOptions.find(opt => opt === correctAnswer);

  // Replace q.options and q.correctAnswer with shuffled versions
  q.options = shuffledOptions;
  q.correctAnswer = newCorrectAnswer;

  progress.done++;
  firstAttempt = true;

  const card = document.createElement('div');
  card.className = 'flashcard';

  const statsRow = document.createElement('div');
  statsRow.style.display = 'flex';
  statsRow.style.justifyContent = 'space-between';
  statsRow.style.marginBottom = '10px';

  const pointsDiv = document.createElement('div');
  pointsDiv.id = 'livePoints';
  pointsDiv.textContent = `Points: ${totalPoints}`;
  const streakDiv = document.createElement('div');
  streakDiv.id = 'liveStreak';
  streakDiv.textContent = `Streak: ${streak}`;
  const progressDiv = document.createElement('div');
  progressDiv.id = 'liveProgress';
  progressDiv.textContent = `Q: ${progress.done}/${progress.total}`;

  statsRow.append(pointsDiv, streakDiv, progressDiv);
  card.appendChild(statsRow);

  const questionDiv = document.createElement('div');
  questionDiv.className = 'question';
  questionDiv.textContent = q.question;
  questionDiv.style.userSelect = 'none';
  questionDiv.style.webkitUserSelect = 'none';
  questionDiv.style.msUserSelect = 'none';
  card.appendChild(questionDiv);

  const optionsList = document.createElement('ul');
  optionsList.className = 'options';

  const explanationDiv = document.createElement('div');
  explanationDiv.className = 'explanation';
  explanationDiv.style.display = 'none';
  explanationDiv.textContent = `Explanation: ${q.explanation}`;
  card.appendChild(explanationDiv);

  let answeredCorrectly = false;

  q.options.forEach(option => {
    const li = document.createElement('li');
    li.textContent = option;
    li.dataset.clicked = 'false';

    li.onclick = () => {
      if (answeredCorrectly) return;
      if (li.dataset.clicked === 'true') return;
      li.dataset.clicked = 'true';

      if (option === q.correctAnswer) {
        handleCorrect(q.topic);
        li.classList.add('correct');
        answeredCorrectly = true;

        Array.from(optionsList.children).forEach(opt => opt.classList.add('answered'));
        if (_nextFlashcardTimer) { clearTimeout(_nextFlashcardTimer); _nextFlashcardTimer = null; }
        _nextFlashcardTimer = setTimeout(() => {
          if (testRunning) generateFlashcard();
        }, 800);
      } else {
        li.classList.add('incorrect');
        explanationDiv.style.display = 'block';
        handleWrong(q.topic);
      }

      if (firstAttempt && option !== q.correctAnswer) firstAttempt = false;
      updateStats();
    };

    optionsList.appendChild(li);
  });

  card.appendChild(optionsList);
  container.appendChild(card);
}

document.addEventListener('keydown', e => {
  if (!['1','2','3','4'].includes(e.key)) return;
  const card = document.querySelector('.flashcard');
  if (!card) return;
  const options = card.querySelectorAll('.options li');
  const idx = parseInt(e.key, 10) - 1;
  if (options[idx]) options[idx].click();
});

function handleCorrect(topic) {
  if (!scores.topics) scores.topics = {};
  if (!scores.topics[topic]) 
    scores.topics[topic] = { correct:0, total:0, firstAttemptCorrect:0 };

  scores.topics[topic].total++;
  scores.topics[topic].correct++;

  if (firstAttempt) {
    scores.topics[topic].firstAttemptCorrect++;
    streak++;
    loseStreak = 0;
    const pts = Math.round(100 + 100 * streak * 0.15);
    totalPoints += pts;
    showFloatingPoints(`+${pts} pts`, true);
  } else {
    streak = 0;
    loseStreak = 0;
  }
}

function handleWrong(topic) {
  if (!scores.topics[topic]) 
    scores.topics[topic] = { correct:0, total:0, firstAttemptCorrect:0 };

  scores.topics[topic].total++;

  streak = 0;
  loseStreak++;
  const lost = Math.round(50 + 50 * loseStreak * 0.15);
  const prev = totalPoints;
  totalPoints = Math.max(0, totalPoints - lost);
  const displayLost = (prev === 0 && totalPoints === 0) ? 0 : lost;
  showFloatingPoints(`-${displayLost} pts`, false);
}

function showFloatingPoints(text, positive){
  const live = document.getElementById('livePoints');
  const container = document.getElementById('floating-container');
  const el = document.createElement('div');
  el.className = 'floating-pts ' + (positive ? 'positive' : 'negative');
  el.textContent = text;

  if (live) {
    const rect = live.getBoundingClientRect();
    el.style.position = 'fixed';
    el.style.left = (rect.right + 8) + 'px';
    el.style.top = (rect.top - 8) + 'px';
    el.style.zIndex = 1350;
    document.body.appendChild(el);
  } else if (container) {
    container.appendChild(el);
  } else {
    el.style.position = 'fixed';
    el.style.left = '50%';
    el.style.top = '18px';
    el.style.transform = 'translateX(-50%)';
    el.style.zIndex = 1350;
    document.body.appendChild(el);
  }

  setTimeout(() => { el.remove(); }, 1100);
}

function updateStats() {
  document.getElementById('livePoints').textContent = `Points: ${totalPoints}`;
  document.getElementById('liveStreak').textContent = `Streak: ${streak}`;
  document.getElementById('liveProgress').textContent = `Q: ${progress.done}/${progress.total}`;
}

function endTest() {
  testRunning = false;
  if (_nextFlashcardTimer) { clearTimeout(_nextFlashcardTimer); _nextFlashcardTimer = null; }
  const container = document.getElementById('flashcard-container');
  container.innerHTML = `
    <h2>Test Complete!</h2>
    <p>You answered ${progress.done} of ${progress.total} questions.</p>
    <p><strong>Total Points: ${totalPoints}</strong></p>
  `;

  const endBtn = document.getElementById('endBtn');
  if (endBtn) endBtn.style.display = 'none';

  const chartContainer = document.getElementById('chart-container');
  chartContainer.style.display = 'block';

  const labels = Object.keys(scores.topics);

  const percentages = labels.map(topic => {
    const { firstAttemptCorrect, total } = scores.topics[topic];
    return total > 0 ? (firstAttemptCorrect / total) * 100 : 0;
  });

  const weights = labels.map(topic => scores.topics[topic].total);
  const data = percentages.map((pct, idx) => pct * weights[idx]);

  const rootStyles = getComputedStyle(document.documentElement);
  const textColor = rootStyles.getPropertyValue('--text-color').trim() || '#102027';
  const surface = rootStyles.getPropertyValue('--surface').trim() || '#e6eef6';

  createTopicChart(document.getElementById('topicChart'), labels, data);

  let newTestBtn = document.getElementById('newTestBtn');
  if (!newTestBtn) {
    newTestBtn = document.createElement('button');
    newTestBtn.id = 'newTestBtn';
    newTestBtn.textContent = 'Start New Test';
    newTestBtn.style.marginTop = '20px';
    newTestBtn.onclick = () => {
      container.innerHTML = '';
      chartContainer.style.display = 'none';
      const sel = document.getElementById('testSelect');
      const custom = document.getElementById('customSelect');
      if (custom) {
        custom.style.display = 'inline-block';
        if (sel) sel.style.display = 'none';
      } else if (sel) {
        sel.style.display = 'inline-block';
      }
      document.getElementById('startBtn').style.display = 'inline-block';
      newTestBtn.remove();
    };
    container.appendChild(newTestBtn);
  }

  let sendBtn = document.getElementById('sendLeaderboardBtn');
  if (!sendBtn) {
    sendBtn = document.createElement('button');
    sendBtn.id = 'sendLeaderboardBtn';
    sendBtn.textContent = 'Send to leaderboard';
    sendBtn.style.marginTop = '12px';
    sendBtn.onclick = () => {
      const testId = (currentTest && currentTest.testName) ? currentTest.testName : (document.getElementById('testSelect').value || 'default');
      showLeaderboardOverlay(testId);
    };
  container.appendChild(sendBtn);
  }
}

let _leaderboardState = { limit: 15, lastLoaded: null };

function showLeaderboardOverlay(testId) {
  let overlay = document.getElementById('lbOverlay');
  if (!overlay) {
    overlay = document.createElement('div');
    overlay.id = 'lbOverlay';
    overlay.className = 'lb-overlay';
    overlay.innerHTML = `
      <div class="lb-panel">
        <button class="lb-close" aria-label="Close">Ã—</button>
        <h3 class="lb-title">Leaderboard</h3>
        <div class="lb-subtitle">Top scores for: <span id="lb-test-name"></span></div>
        <div class="lb-list" id="lbList" role="list"></div>
        <div class="lb-bottom">
          <div class="lb-controls">
            <button id="lbShowMore">Show more</button>
          </div>
          <div class="lb-submit">
            <input id="lbName" placeholder="Your name" maxlength="30" />
            <button id="lbSubmitBtn">Submit score</button>
          </div>
        </div>
      </div>
    `;
    document.body.appendChild(overlay);

    overlay.querySelector('.lb-close').addEventListener('click', closeLeaderboard);
    overlay.querySelector('#lbShowMore').addEventListener('click', async (e) => {
      _leaderboardState.limit += 15;
      await fetchAndRenderLeaderboard(testId);
    });
    overlay.querySelector('#lbSubmitBtn').addEventListener('click', async () => {
      const name = document.getElementById('lbName').value.trim() || 'Anonymous';
        try {
        if (!window.leaderboardApi || !window.leaderboardApi.submitScore) throw new Error('Leaderboard API not available');
        if (window.leaderboardAuthReady) await window.leaderboardAuthReady;
        if (!totalPoints || Number(totalPoints) === 0) {
          showToast('Cannot submit a score of 0.', 'error');
          return;
        }
        const localKey = `fblacer_sub_${testId}||${name}||${totalPoints}`;
        if (localStorage.getItem(localKey)) {
          showToast('You can only submit the same score once.', 'info');
          const submitWrap = overlay.querySelector('.lb-submit');
          if (submitWrap) submitWrap.remove();
          return;
        }
  await window.leaderboardApi.submitScore(testId, name, totalPoints);
  await fetchAndRenderLeaderboard(testId);
        document.getElementById('lbName').value = '';
        try { localStorage.setItem(localKey, JSON.stringify({ ts: new Date().toISOString() })); } catch (e) { }
        const submitWrap2 = overlay.querySelector('.lb-submit');
        if (submitWrap2) {
          const note = document.createElement('div');
          note.className = 'lb-submitted';
          note.textContent = 'Sent successfully';
          submitWrap2.parentNode.replaceChild(note, submitWrap2);
        }
        showToast('Sent successfully', 'success');
      } catch (err) {
        const msg = (err && err.message) ? err.message : String(err);
        if (msg.toLowerCase().includes('permission') || msg.toLowerCase().includes('missing')) {
          showToast('Failed to submit score: insufficient permissions.', 'error');
        } else {
          showToast('Failed to submit score: ' + msg, 'error');
        }
      }
    });
  }

  const testNameEl = document.getElementById('lb-test-name');
  if (testNameEl) testNameEl.textContent = testId;
  overlay.style.cssText = 'position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.45);z-index:99999;';
  const panelEl = overlay.querySelector('.lb-panel');
  if (panelEl) {
    panelEl.style.position = 'relative';
    panelEl.style.maxHeight = '86vh';
    panelEl.style.overflow = 'hidden';
    panelEl.style.width = 'min(820px,96%)';
  }
  const listEl = overlay.querySelector('#lbList');
  if (listEl) {
    listEl.style.overflow = 'auto';
    listEl.style.maxHeight = '56vh';
  }
  document.body.style.overflow = 'hidden';
  _leaderboardState.limit = 15;
  fetchAndRenderLeaderboard(testId);
}

function closeLeaderboard() {
  const overlay = document.getElementById('lbOverlay');
  if (overlay) overlay.style.display = 'none';
  document.body.style.overflow = '';
}

async function fetchAndRenderLeaderboard(testId) {
  const listEl = document.getElementById('lbList');
  if (!listEl) return;
  listEl.innerHTML = '<div class="lb-loading">Loading\u0000</div>';
  try {
    if (!window.leaderboardApi || !window.leaderboardApi.fetchTopScores) throw new Error('Leaderboard API not available');
    const entries = await window.leaderboardApi.fetchTopScores(testId, _leaderboardState.limit);
    renderLeaderboardEntries(entries);
  } catch (err) {
    listEl.innerHTML = '<div class="lb-error">Failed to load leaderboard</div>';
  }
}

function renderLeaderboardEntries(entries) {
  const listEl = document.getElementById('lbList');
  if (!listEl) return;
  if (!entries || entries.length === 0) {
    listEl.innerHTML = '<div class="lb-empty">No scores yet. Be the first to submit!</div>';
    return;
  }
  listEl.innerHTML = '';
  entries.forEach((e, idx) => {
    const item = document.createElement('div');
    item.className = 'lb-item';
    let tsText = '';
    try {
      const ts = e.createdAt;
      let d = null;
      if (!ts) d = null;
      else if (typeof ts.toDate === 'function') d = ts.toDate();
      else if (ts.seconds) d = new Date(Number(ts.seconds) * 1000);
      else d = new Date(ts);
      if (d && !isNaN(d.getTime())) tsText = d.toLocaleString();
    } catch (err) { tsText = ''; }
    item.innerHTML = `<div class="lb-rank">${idx+1}</div><div class="lb-name">${escapeHtml(e.name || 'Anonymous')}<div class="lb-timestamp">${tsText}</div></div><div class="lb-points">${Number(e.points) || 0}</div>`;
    listEl.appendChild(item);
  });
}

function escapeHtml(s) {
  return String(s).replace(/[&"'<>]/g, function (c) {
    return ({
      '&': '&amp;',
      '"': '&quot;',
      "'": '&#39;',
      '<': '&lt;',
      '>': '&gt;'
    })[c];
  });
}

function ensureToastContainer() {
  let wrap = document.getElementById('toastWrap');
  if (!wrap) {
    wrap = document.createElement('div');
    wrap.id = 'toastWrap';
    wrap.className = 'toast-wrap';
    document.body.appendChild(wrap);
  }
  return wrap;
}

function showToast(message, kind = 'info', timeout = 3500) {
  const wrap = ensureToastContainer();
  const el = document.createElement('div');
  el.className = 'toast ' + (kind || 'info');
  el.textContent = message;
  wrap.appendChild(el);
  setTimeout(() => { el.style.transition = 'opacity 300ms'; el.style.opacity = '0'; setTimeout(() => el.remove(), 350); }, timeout);
}

async function submitScore(name, test, score) {
  try {
    if (!name || !test || typeof score !== 'number') {
      return;
    }
    const docId = `${name}-${test}`.replace(/\s+/g, '_');
    if (!window.leaderboardApi || !window.leaderboardApi.setScoreDoc) throw new Error('leaderboardApi.setScoreDoc not available');
    await window.leaderboardAuthReady;
    if (!score || Number(score) === 0) {
      return;
    }
    const localKey = `fblacer_sub_${test}||${name}||${score}`;
    if (localStorage.getItem(localKey)) {
      return;
    }
    const createdAt = new Date().toISOString();
    await window.leaderboardApi.setScoreDoc(test, docId, { name, test, points: score, createdAt });
  try { localStorage.setItem(localKey, JSON.stringify({ ts: createdAt })); } catch (e) { }
  } catch (err) {
  }
}
window.submitScore = submitScore;
